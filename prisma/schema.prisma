// Prisma v6 Schema - COMPLETELY FIXED VERSION WITH GROUP-ONLY REPORT SYSTEM
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ============= ENUMS =============
enum UserRole {
  USER
  GROUP_ADMIN
}

enum UserRoleStatus {
  ACTIVE
  SUSPENDED
  DISABLED
}

enum GroupMemberRole {
  ADMIN
  MEMBER
}

enum SystemAdminRole {
  SUPER_ADMIN
  SUPPORT
  ANALYST
}

enum TokenType {
  ACCESS
  REFRESH
  PASSWORD_RESET
  EMAIL_VERIFICATION
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

// Days of week for scheduling
enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

// Task Execution Frequency (How often task needs to be done)
enum TaskExecutionFrequency {
  DAILY
  WEEKLY
}

// Feedback Types
enum FeedbackType {
  BUG
  FEATURE_REQUEST
  GENERAL
  SUGGESTION
  COMPLAINT
  QUESTION
  OTHER
}

// Feedback Status
enum FeedbackStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

// Report Types
enum ReportType {
  INAPPROPRIATE_CONTENT
  HARASSMENT
  SPAM
  OFFENSIVE_BEHAVIOR
  TASK_ABUSE
  GROUP_MISUSE
  OTHER
}

enum ReportStatus {
  PENDING
  REVIEWING
  RESOLVED
  DISMISSED
}

// ============= CORE MODELS =============
model User {
  id           String  @id @default(uuid())
  email        String  @unique
  passwordHash String
  fullName     String
  avatarUrl    String?
  gender       Gender?

  role       UserRole       @default(USER)
  roleStatus UserRoleStatus @default(ACTIVE)

  roleStatusChangedAt DateTime?
  roleStatusChangedBy String?
  roleStatusReason    String?

  settings Json? @default("{}")

  // Password Reset Fields
  resetPasswordToken   String?   @unique
  resetPasswordExpires DateTime?

  // Relationships
  groups            GroupMember[]      @relation("UserGroups")
  createdGroups     Group[]            @relation("GroupCreator")
  createdTasks      Task[]             @relation("TaskCreator")
  assignments       Assignment[]       @relation("UserAssignments")
  feedback          Feedback[]         @relation("UserFeedback")
  userNotifications UserNotification[]
  refreshTokens     RefreshToken[]     @relation("UserRefreshTokens")
  reports           Report[]           @relation("UserReports")

  statusChangedByAdmin SystemAdmin? @relation("StatusChangedByAdmin", fields: [roleStatusChangedBy], references: [id])

  adminModifications AdminAuditLog[] @relation("UserAdminAuditLogs")

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  @@map("users")
}

model Group {
  id          String  @id @default(uuid())
  name        String
  description String?
  inviteCode  String  @unique
  avatarUrl   String?
  settings    Json?   @default("{}")

  createdById String

  // Rotation tracking
  currentRotationWeek Int       @default(0) // Current week in rotation cycle
  lastRotationUpdate  DateTime? // When rotation was last updated

  // Relationships
  members GroupMember[] @relation("GroupMembers")
  tasks   Task[]        @relation("GroupTasks")
  creator User          @relation("GroupCreator", fields: [createdById], references: [id])
  reports Report[]      @relation("GroupReports")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("groups")
}

model GroupMember {
  id        String          @id @default(uuid())
  userId    String
  groupId   String
  groupRole GroupMemberRole @default(MEMBER)

  // For rotation tracking
  rotationOrder Int? // Order in rotation sequence
  isActive      Boolean @default(true) // Whether member participates in rotation

  // Relationships
  user  User  @relation("UserGroups", fields: [userId], references: [id], onDelete: Cascade)
  group Group @relation("GroupMembers", fields: [groupId], references: [id], onDelete: Cascade)

  joinedAt DateTime @default(now())

  @@unique([userId, groupId])
  @@map("group_members")
}

model Task {
  id          String  @id @default(uuid())
  title       String
  description String?
  points      Int     @default(1)

  // Task Execution Frequency (DAILY or WEEKLY)
  executionFrequency TaskExecutionFrequency @default(WEEKLY)

  // For WEEKLY tasks: Store multiple days in JSON
  selectedDays Json? // JSON array of DayOfWeek enum values: ["MONDAY", "WEDNESDAY", "FRIDAY"]

  // Multiple time slots relationship
  timeSlots TimeSlot[] @relation("TaskTimeSlots")

  // For quick access, store primary time slot
  primaryTimeSlotId String? @unique

  // Keep for backward compatibility
  scheduledTime String? // Legacy single time (e.g., "09:00", "14:30", "18:45")
  timeFormat    String? @default("12h") // "12h" or "24h"

  // Legacy fields
  timeOfDay   String? // Deprecated
  dayOfWeek   DayOfWeek? // Legacy single day
  isRecurring Boolean    @default(true)
  category    String?

  // Rotation tracking
  rotationOrder   Int? // Order in the rotation sequence
  currentAssignee String? // Current user assigned (for easier querying)
  lastAssignedAt  DateTime? // When it was last assigned to someone

  // Store which members are in rotation for this specific task
  rotationMembers Json? // JSON array: [{userId: "uuid", fullName: "John Doe", rotationOrder: 1}]

  // Foreign keys
  groupId     String
  createdById String

  // Relationships
  group           Group        @relation("GroupTasks", fields: [groupId], references: [id], onDelete: Cascade)
  creator         User         @relation("TaskCreator", fields: [createdById], references: [id])
  assignments     Assignment[] @relation("TaskAssignments")
  primaryTimeSlot TimeSlot?    @relation("TaskPrimaryTimeSlot", fields: [primaryTimeSlotId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("tasks")
}

// TimeSlot model
model TimeSlot {
  id        String  @id @default(uuid())
  taskId    String
  startTime String // e.g., "08:00"
  endTime   String // e.g., "10:00"
  label     String? // Optional: "Morning", "Afternoon", "Evening", "Breakfast", "Lunch", "Dinner"

  // Points for this specific time slot (null = use task points)
  points Int?

  // For ordering time slots
  sortOrder Int @default(0)

  // Whether this is the primary/default time slot
  isPrimary Boolean @default(false)

  // Relationships
  task           Task         @relation("TaskTimeSlots", fields: [taskId], references: [id], onDelete: Cascade)
  primaryForTask Task?        @relation("TaskPrimaryTimeSlot")
  assignments    Assignment[] @relation("TimeSlotAssignments")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([taskId])
  @@index([sortOrder])
  @@index([isPrimary])
  @@map("time_slots")
}

model Assignment {
  id      String   @id @default(uuid())
  taskId  String
  userId  String
  dueDate DateTime

  // Points awarded for this specific assignment
  points Int @default(1)

  completed   Boolean   @default(false)
  completedAt DateTime?
  verified    Boolean   @default(false)
  photoUrl    String?

  // User notes when completing task
  notes String? @db.Text

  // Admin notes when verifying
  adminNotes String?

  // Track which specific time slot this assignment is for
  timeSlotId String?

  // Rotation tracking
  rotationWeek  Int        @default(0)
  weekStart     DateTime? // ‚Üê CHANGED TO OPTIONAL (allow NULL)
  weekEnd       DateTime? // ‚Üê CHANGED TO OPTIONAL (allow NULL)
  assignmentDay DayOfWeek?

  // Relationships
  task         Task          @relation("TaskAssignments", fields: [taskId], references: [id], onDelete: Cascade)
  user         User          @relation("UserAssignments", fields: [userId], references: [id])
  swapRequests SwapRequest[] @relation("AssignmentSwapRequests") // ‚Üê CHANGED to one-to-many
  timeSlot     TimeSlot?     @relation("TimeSlotAssignments", fields: [timeSlotId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([dueDate])
  @@index([completed])
  @@index([userId, completed])
  @@index([rotationWeek])
  @@index([weekStart, weekEnd])
  @@index([assignmentDay])
  @@index([timeSlotId])
  @@map("assignments")
}

model SwapRequest {
  id           String  @id @default(uuid())
  assignmentId String
  reason       String?
  status       String  @default("PENDING")

  // For tracking swaps
  requestedBy  String
  targetUserId String?
  expiresAt    DateTime?

  // Swap scope fields
  scope              String? @default("week") // "week" or "day"
  selectedDay        String? // "MONDAY", "TUESDAY", etc. - only if scope is "day"
  selectedTimeSlotId String? // Specific time slot ID - optional

  // ‚úÖ FIXED: Changed to one-to-many relation
  assignment Assignment @relation("AssignmentSwapRequests", fields: [assignmentId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("swap_requests")
}

// ============= REPORT MODEL - GROUP ONLY =============
model Report {
  id          String       @id @default(uuid())
  reporterId  String // User who filed the report
  groupId     String // Group being reported
  type        ReportType
  description String       @db.Text
  status      ReportStatus @default(PENDING)

  // Admin resolution
  resolvedBy      String?
  resolutionNotes String?   @db.Text
  resolvedAt      DateTime?

  // Relationships - FIXED with unique relation names
  reporter User         @relation("UserReports", fields: [reporterId], references: [id], onDelete: Cascade)
  group    Group        @relation("GroupReports", fields: [groupId], references: [id], onDelete: Cascade)
  resolver SystemAdmin? @relation("ResolvedReports", fields: [resolvedBy], references: [id]) // üëà FIXED: Added relation name

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([groupId])
  @@index([reporterId])
  @@index([status])
  @@index([createdAt])
  @@map("reports")
}

// ============= FEEDBACK MODEL =============
model Feedback {
  id       String  @id @default(uuid())
  userId   String
  type     String
  message  String
  status   String  @default("OPEN")
  category String?

  // Relationships
  user User @relation("UserFeedback", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@map("feedback")
}

// ============= NOTIFICATION MODELS =============

// For MOBILE APP USERS
model UserNotification {
  id      String  @id @default(uuid())
  userId  String
  type    String
  title   String
  message String
  data    Json?
  read    Boolean @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([read])
  @@index([createdAt])
  @@map("user_notifications")
}

// For WEB ADMIN DASHBOARD
model AdminNotification {
  id       String  @id @default(uuid())
  adminId  String?
  type     String
  title    String
  message  String
  data     Json?
  read     Boolean @default(false)
  priority String  @default("NORMAL")

  admin SystemAdmin? @relation(fields: [adminId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([adminId])
  @@index([read])
  @@index([priority])
  @@index([createdAt])
  @@map("admin_notifications")
}

// ============= SYSTEM ADMINS =============

model SystemAdmin {
  id           String          @id @default(uuid())
  email        String          @unique
  passwordHash String
  fullName     String
  role         SystemAdminRole @default(SUPPORT)
  permissions  Json?           @default("[]")

  // Relationships
  modifiedUsers      User[]              @relation("StatusChangedByAdmin")
  auditLogs          AdminAuditLog[]     @relation("AdminAuditLogs")
  adminNotifications AdminNotification[] // Admin notifications
  refreshTokens      AdminRefreshToken[] @relation("AdminRefreshTokens")
  resolvedReports    Report[]            @relation("ResolvedReports") // üëà FIXED: Matches the resolver relation name

  // Status
  lastLoginAt DateTime?
  isActive    Boolean   @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("system_admins")
}

model AdminAuditLog {
  id           String  @id @default(uuid())
  adminId      String
  targetUserId String?
  action       String
  details      Json?
  ipAddress    String?
  userAgent    String?

  // Relationships
  admin      SystemAdmin @relation("AdminAuditLogs", fields: [adminId], references: [id], onDelete: Cascade)
  targetUser User?       @relation("UserAdminAuditLogs", fields: [targetUserId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([adminId])
  @@index([targetUserId])
  @@index([createdAt])
  @@map("admin_audit_logs")
}

// ============= AUTHENTICATION MODELS =============

// For MOBILE APP USERS
model RefreshToken {
  id        String    @id @default(uuid())
  userId    String
  token     String    @unique @db.VarChar(1000)
  type      TokenType @default(REFRESH)
  expiresAt DateTime
  revoked   Boolean   @default(false)

  user User @relation("UserRefreshTokens", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([token])
  @@map("refresh_tokens")
}

// For WEB ADMIN USERS (separate from mobile users)
model AdminRefreshToken {
  id        String    @id @default(uuid())
  adminId   String
  token     String    @unique @db.VarChar(1000)
  type      TokenType @default(REFRESH)
  expiresAt DateTime
  revoked   Boolean   @default(false)

  admin SystemAdmin @relation("AdminRefreshTokens", fields: [adminId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([adminId])
  @@index([token])
  @@map("admin_refresh_tokens")
}
